<?php

namespace PMT\TaskBundle\Entity;

use Gedmo\Sortable\Entity\Repository\SortableRepository;
use PMT\ProjectBundle\Entity\Project;

/**
 * TaskRepository
 *
 * This class was generated by the Doctrine ORM. Add your own custom
 * repository methods below.
 */
class TaskRepository extends SortableRepository
{

    public function filter($filter, $project_id, $user_id)
    {
        $this->getEntityManager()->getFilters()->getFilter('softdeleteable')->disableForEntity('PMT\UserBundle\Entity\User');
        $qb = $this->createQueryBuilder('t');
        $qb->addSelect('u');
        $qb->addSelect('a');
        $qb->leftJoin('t.assignedUsers', 'u');
        $qb->leftJoin('t.user', 'a');
        $qb->where($qb->expr()->eq('t.project', ':project_id'))
            ->setParameter('project_id', $project_id);

        if ($filter['assignment'] == 'assigned') {
            $qb->andWhere($qb->expr()->eq('u.id', ':user_id'))
                ->setParameter('user_id', $user_id);
        } elseif ($filter['assignment'] == 'unassigned') {
            $qb->andWhere($qb->expr()->isNull('u.id'));
        }

        if ($filter['categories']) {
            $qb->andWhere($qb->expr()->in('t.category', ':categories'))
                ->setParameter('categories', $filter['categories']);
        }

        if ($filter['statuses']) {
            $qb->andWhere($qb->expr()->in('t.status', ':statuses'))
                ->setParameter('statuses', $filter['statuses']);
        }

        if ($filter['date_start']) {
            $filter['date_start'] = $filter['date_start'].' 00:00:00';

            $qb->andWhere($qb->expr()->gte('t.createdAt', ':date_start'))
                ->setParameter(':date_start', $filter['date_start']);
        }

        if ($filter['date_end']) {
            $filter['date_end'] = $filter['date_end'].' 23:59:59';
            $qb->andWhere($qb->expr()->lte('t.createdAt', ':date_end'))
                ->setParameter('date_end', $filter['date_end']);
        }

        if ($filter['order'] == 'date') {
            $qb->orderBy('t.createdAt', 'DESC');
        } elseif ($filter['order'] == 'progress') {
          $qb->orderBy('t.progress', 'DESC');
        } elseif ($filter['order'] == 'name') {
          $qb->orderBy('t.name', 'ASC');
        } else {
            $qb->orderBy('t.position', 'ASC');
        }

        $tasks = $qb->getQuery()->getResult();

        $this->getEntityManager()->getFilters()->getFilter('softdeleteable')->enableForEntity('PMT\UserBundle\Entity\User');

        $durations = $this->getDurations($filter);

        return array($tasks, $durations);
    }

    public function getDurations($filter)
    {
        $durations = array();

        $con = $this->getEntityManager()->getConnection();
        $stmt = $con->prepare('SELECT t.id, SUM(TIMESTAMPDIFF(SECOND, started_at, ended_at)) AS sum
                FROM pmt_tracks tr JOIN pmt_tasks t ON tr.task_id=t.id
                WHERE t.deleted_at IS NULL
                    AND tr.deleted_at IS NULL
                    AND t.created_at BETWEEN ? AND ?
                    AND t.status IN ('.implode(',', array_fill(0, count($filter['statuses']), '?')).')
                GROUP BY t.id');
        $stmt->execute(array_merge(array($filter['date_start'], $filter['date_end']), $filter['statuses']));

        while ($row = $stmt->fetch(\PDO::FETCH_ASSOC)) {
            $durations[$row['id']] = round($row['sum']/3600, 2);
        }

        return $durations;
    }

    public function getDuration(Task $task)
    {
        $qb = $this->getEntityManager()->createQueryBuilder();
        $qb->select('SUM(TIMESTAMPDIFF(SECOND, track.startedAt, track.endedAt))')
            ->from('PMTTrackingBundle:Track', 'track')
            ->andWhere('track.task=:task')
            ->setParameter(':task', $task);

        $result = $qb->getQuery()->getSingleResult();

        return round($result[1] / 3600, 2);
    }

    public function updateProgress(Task $task)
    {
        $full = array(
            'complete',
            'merge',
            'merged',
            'done');

        if (in_array($task->getStatus(), $full)) {
            $task->setProgress(100);
        } elseif ($task->getProgress() == 100) {
            $task->setProgress(0);
        }

        if ($task->getProgress() < 89) {
            $con = $this->getEntityManager()->getConnection();
            $stmt = $con->prepare('SELECT SUM(TIMESTAMPDIFF(SECOND, started_at, ended_at)) AS sum FROM pmt_tracks WHERE deleted_at IS NULL AND task_id = :task_id');
            $stmt->execute(array('task_id' => $task->getId()));
            $res = $stmt->fetch(\PDO::FETCH_ASSOC);

            if (isset($res['sum']) && $task->getEstimatedTime()) {
                $task->setProgress(min(round(($res['sum']/$task->getEstimatedTime())*100), 89));
            } else {
                $task->setProgress(0);
            }
        }

        $this->getEntityManager()->persist($task);
        $this->getEntityManager()->flush($task);
    }

    public function getInProgress(Project $project)
    {
        $in_progress = array();

        $con = $this->getEntityManager()->getConnection();
        $stmt = $con->prepare('SELECT tr.task_id, tr.user_id FROM pmt_tracks tr JOIN pmt_tasks t ON tr.task_id=t.id WHERE t.project_id=? AND tr.updated_at >= ? ORDER BY tr.updated_at DESC');
        $ago = new \DateTime('-1 minute', new \DateTimeZone('UTC'));
        $stmt->execute(array($project->getId(), $ago->format('Y-m-d H:i:s')));

        $users = array();
        while ($row = $stmt->fetch(\PDO::FETCH_ASSOC)) {
            if (!in_array($row['user_id'], $users)) {
                if (!isset($in_progress[$row['task_id']])) {
                    $in_progress[$row['task_id']] = array();
                }

                $in_progress[$row['task_id']][] = $row['user_id'];
                $users[] = $row['user_id'];
            }
        }

        return $in_progress;
    }

    public function search($term, $page, $router)
    {
        $results = array();

        $con = $this->getEntityManager()->getConnection();
        $stmt = $con->prepare('SELECT t.id, t.project_id, t.name, ((MATCH(txt.name) AGAINST (:term))*2 + MATCH(txt.description) AGAINST (:term)) AS score
FROM pmt_tasks_texts txt JOIN pmt_tasks t ON txt.task_id=t.id
WHERE MATCH(txt.name, txt.description) AGAINST (:term IN BOOLEAN MODE)
  OR id=:term
ORDER BY score DESC, t.id DESC
LIMIT 15
OFFSET :offset');
        $stmt->bindValue('offset', ($page-1)*15, \PDO::PARAM_INT);
        $stmt->bindValue('term', $term);
        $stmt->execute();

        foreach ($stmt->fetchAll(\PDO::FETCH_ASSOC) as $row) {
            $results[] = array('id' => $row['id'],
                'text' => '#'.$row['id'].': '.$row['name'],
                'url' => $router->generate('project_task',
                    array('id' => $row['id'], 'project_id' => $row['project_id']))
            );
        }

        return $results;
    }

    public function getCommentUsers(Task $task)
    {
        $qb = $this->getEntityManager()->createQueryBuilder();
        $qb->select('DISTINCT u')
            ->from('PMTUserBundle:User', 'u')
            ->join('u.comments', 'c')
            ->andWhere('c.task = :id')
            ->setParameter('id', $task->getId());

        return $qb->getQuery()->getResult();
    }
}

<?php

namespace PMT\TaskBundle\Entity;

use Doctrine\ORM\EntityRepository;
use Gedmo\Sortable\Entity\Repository\SortableRepository;


/**
 * TaskRepository
 *
 * This class was generated by the Doctrine ORM. Add your own custom
 * repository methods below.
 */
class TaskRepository extends SortableRepository
{
    
    public function filter($filter, $project_id, $user_id)
    {
        $this->getEntityManager()->getFilters()->getFilter('softdeleteable')->disableForEntity('PMT\UserBundle\Entity\User');
        $qb = $this->createQueryBuilder('t');
        $qb->addSelect('u');
        $qb->addSelect('a');
        $qb->leftJoin('t.assignedUsers', 'u');
        $qb->leftJoin('t.user', 'a');
        $qb->where($qb->expr()->eq('t.project', ':project_id'))
            ->setParameter('project_id', $project_id);
        
        if($filter['assignment'] == 'assigned')
        {
            $qb->andWhere($qb->expr()->eq('u.id', ':user_id'))
                ->setParameter('user_id', $user_id);
        }
        elseif($filter['assignment'] == 'unassigned')
        {
            $qb->andWhere($qb->expr()->isNull('u.id'));
        }
        
        if($filter['categories'])
        {
            $qb->andWhere($qb->expr()->in('t.category', ':categories'))
                ->setParameter('categories', $filter['categories']);
        }
        
        if($filter['statuses'])
        {
            $qb->andWhere($qb->expr()->in('t.status', ':statuses'))
                ->setParameter('statuses', $filter['statuses']);
        }
        
        if($filter['date_start'])
        {
            $filter['date_start'] = $filter['date_start'].' 00:00:00';
            
            $qb->andWhere($qb->expr()->gte('t.createdAt', ':date_start'))
                ->setParameter(':date_start', $filter['date_start']);
        }
        
        if($filter['date_end'])
        {
            $filter['date_end'] = $filter['date_end'].' 23:59:59';
            $qb->andWhere($qb->expr()->lte('t.createdAt', ':date_end'))
                ->setParameter('date_end', $filter['date_end']);
        }
        
        if($filter['order'] == 'date')
        {
            $qb->orderBy('t.createdAt', 'DESC');
        }
        elseif($filter['order'] == 'progress')
        {
          $qb->orderBy('t.progress', 'DESC');
        }
        elseif($filter['order'] == 'name')
        {
          $qb->orderBy('t.name', 'ASC');
        }
        else
        {
            $qb->orderBy('t.position', 'ASC');
        }
        
        $tasks = $qb->getQuery()->getResult();

        $this->getEntityManager()->getFilters()->getFilter('softdeleteable')->enableForEntity('PMT\UserBundle\Entity\User');

        $durations = $this->getDurations($filter);
        
        return array($tasks, $durations);
    }
    
    public function getDurations($filter)
    {
        $durations = array();

        $con = $this->getEntityManager()->getConnection();
        $stmt = $con->prepare('SELECT t.id, SUM(TIMESTAMPDIFF(SECOND, started_at, ended_at)) AS sum
                FROM pmt_tracks tr JOIN pmt_tasks t ON tr.task_id=t.id
                WHERE t.deleted_at IS NULL
                    AND tr.deleted_at IS NULL
                    AND t.created_at BETWEEN ? AND ?
                    AND t.status IN ('.implode(',', array_fill(0, count($filter['statuses']), '?')).')
                GROUP BY t.id');
        $stmt->execute(array_merge(array($filter['date_start'], $filter['date_end']), $filter['statuses']));
        
        while($row = $stmt->fetch(\PDO::FETCH_ASSOC))
        {
            $durations[$row['id']] = round($row['sum']/3600, 2);
        }
        
        return $durations;
    }
    
    public function updateProgress(Task $task)
    {
        if($task->getProgress() < 89)
        {
            $con = $this->getEntityManager()->getConnection();
            $stmt = $con->prepare('SELECT SUM(TIMESTAMPDIFF(SECOND, started_at, ended_at)) AS sum FROM pmt_tracks WHERE deleted_at IS NULL AND task_id = :task_id');
            $stmt->execute(array('task_id' => $task->getId()));
            $res = $stmt->fetch(\PDO::FETCH_ASSOC);
            
            if(isset($res['sum']) && $task->getEstimatedTime())
            {
                $task->setProgress(min(round(($res['sum']/$task->getEstimatedTime())*100), 89));
            }
            else
            {
                $task->setProgress(0);
            }
            
            $this->getEntityManager()->persist($task);
            $this->getEntityManager()->flush($task);
        }
    }
    
    public function getInProgress()
    {
        $in_progress = array();

        $con = $this->getEntityManager()->getConnection();
        $stmt = $con->prepare('SELECT task_id, user_id FROM pmt_tracks WHERE updated_at >= ? ORDER BY updated_at DESC');
        $ago = new \DateTime('-1 minute', new \DateTimeZone('UTC'));
        $stmt->execute(array($ago->format('Y-m-d H:i:s')));

        $users = array();
        while($row = $stmt->fetch(\PDO::FETCH_ASSOC))
        {            
            if(!in_array($row['user_id'], $users))
            {
                if(!isset($in_progress[$row['task_id']]))
                {
                    $in_progress[$row['task_id']] = array();
                }
                
                $in_progress[$row['task_id']][] = $row['user_id'];
                $users[] = $row['user_id'];
            }
        }

        return $in_progress;
    }
    
    public function search($term, $page, $router)
    {
        $results = array();

        $con = $this->getEntityManager()->getConnection();
        $stmt = $con->prepare('SELECT t.id, t.project_id, t.name, ((MATCH(txt.name) AGAINST (:term))*2 + MATCH(txt.description) AGAINST (:term)) AS score
FROM pmt_tasks_texts txt JOIN pmt_tasks t ON txt.task_id=t.id
WHERE MATCH(txt.name, txt.description) AGAINST (:term IN BOOLEAN MODE)
  OR id=:term
ORDER BY score DESC, t.id DESC
LIMIT 15
OFFSET :offset');
        $stmt->bindValue('offset', ($page-1)*15, \PDO::PARAM_INT);
        $stmt->bindValue('term', $term);
        $stmt->execute();

        foreach($stmt->fetchAll(\PDO::FETCH_ASSOC) as $row)
        {
            $results[] = array('id' => $row['id'],
                'text' => '#'.$row['id'].': '.$row['name'],
                'url' => $router->generate('project_task',
                    array('id' => $row['id'], 'project_id' => $row['project_id']))
            );
        }

        return $results;
    }
}
